// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "Headers.dart" as headers_;

import "RequestBody.dart" as requestbody_;

/// from: okhttp3.Request
///
/// An HTTP request. Instances of this class are immutable if their \#body is null or itself
/// immutable.
class Request extends jni.JObject {
  @override
  late final jni.JObjType<Request> $type = type;

  Request.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Request");

  /// The type which includes information such as the signature of this class.
  static const type = $RequestType();
  static final _id_url = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"url", r"()Lokhttp3/HttpUrl;");

  /// from: public okhttp3.HttpUrl url()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject url() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_url, jni.JniCallType.objectType, []).object);
  }

  static final _id_method = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"method", r"()Ljava/lang/String;");

  /// from: public java.lang.String method()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString method() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_method, jni.JniCallType.objectType, []).object);
  }

  static final _id_headers = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"headers", r"()Lokhttp3/Headers;");

  /// from: public okhttp3.Headers headers()
  /// The returned object must be released after use, by calling the [release] method.
  headers_.Headers headers() {
    return const headers_.$HeadersType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_headers, jni.JniCallType.objectType, []).object);
  }

  static final _id_header = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"header", r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String header(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header(
    jni.JString name,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_header,
        jni.JniCallType.objectType,
        [name.reference]).object);
  }

  static final _id_headers1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"headers", r"(Ljava/lang/String;)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> headers(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> headers1(
    jni.JString name,
  ) {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_headers1, jni.JniCallType.objectType,
            [name.reference]).object);
  }

  static final _id_body = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"body", r"()Lokhttp3/RequestBody;");

  /// from: public okhttp3.RequestBody body()
  /// The returned object must be released after use, by calling the [release] method.
  requestbody_.RequestBody body() {
    return const requestbody_.$RequestBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_body, jni.JniCallType.objectType, []).object);
  }

  static final _id_tag = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"tag", r"()Ljava/lang/Object;");

  /// from: public java.lang.Object tag()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the tag attached with {@code Object.class} as a key, or null if no tag is attached with
  /// that key.
  ///
  /// Prior to OkHttp 3.11, this method never returned null if no tag was attached. Instead it
  /// returned either this request, or the request upon which this request was derived with \#newBuilder().
  jni.JObject tag() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_tag, jni.JniCallType.objectType, []).object);
  }

  static final _id_tag1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"tag", r"(Ljava/lang/Class;)Ljava/lang/Object;");

  /// from: public T tag(java.lang.Class<? extends T> type)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the tag attached with {@code type} as a key, or null if no tag is attached with that
  /// key.
  $T tag1<$T extends jni.JObject>(
    jni.JObject type0, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(jni.Jni.accessors.callMethodWithArgs(reference, _id_tag1,
        jni.JniCallType.objectType, [type0.reference]).object);
  }

  static final _id_newBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newBuilder", r"()Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder newBuilder() {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_newBuilder, jni.JniCallType.objectType, []).object);
  }

  static final _id_cacheControl = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"cacheControl", r"()Lokhttp3/CacheControl;");

  /// from: public okhttp3.CacheControl cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the cache control directives for this response. This is never null, even if this
  /// response contains no {@code Cache-Control} header.
  jni.JObject cacheControl() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cacheControl, jni.JniCallType.objectType, []).object);
  }

  static final _id_isHttps =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isHttps", r"()Z");

  /// from: public boolean isHttps()
  bool isHttps() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isHttps, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $RequestType extends jni.JObjType<Request> {
  const $RequestType();

  @override
  String get signature => r"Lokhttp3/Request;";

  @override
  Request fromRef(jni.JObjectPtr ref) => Request.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestType) && other is $RequestType;
  }
}

/// from: okhttp3.Request$Builder
class Request_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Request_Builder> $type = type;

  Request_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Request$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $Request_BuilderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Request_Builder() {
    return Request_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_url = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"url", r"(Lokhttp3/HttpUrl;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder url(okhttp3.HttpUrl url)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url(
    jni.JObject url,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_url, jni.JniCallType.objectType,
            [url.reference]).object);
  }

  static final _id_url1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"url", r"(Ljava/lang/String;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder url(java.lang.String url)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the URL target of this request.
  ///@throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
  /// exception by calling HttpUrl\#parse; it returns null for invalid URLs.
  Request_Builder url1(
    jni.JString url,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_url1, jni.JniCallType.objectType,
            [url.reference]).object);
  }

  static final _id_url2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"url", r"(Ljava/net/URL;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder url(java.net.URL url)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the URL target of this request.
  ///@throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
  /// https}.
  Request_Builder url2(
    jni.JObject url,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_url2, jni.JniCallType.objectType,
            [url.reference]).object);
  }

  static final _id_header = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"header",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder header(java.lang.String name, java.lang.String value)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the header named {@code name} to {@code value}. If this request already has any headers
  /// with that name, they are all replaced.
  Request_Builder header(
    jni.JString name,
    jni.JString value,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_header, jni.JniCallType.objectType,
            [name.reference, value.reference]).object);
  }

  static final _id_addHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addHeader",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder addHeader(java.lang.String name, java.lang.String value)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
  /// headers like "Cookie".
  ///
  /// Note that for some headers including {@code Content-Length} and {@code Content-Encoding},
  /// OkHttp may replace {@code value} with a header derived from the request body.
  Request_Builder addHeader(
    jni.JString name,
    jni.JString value,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_addHeader,
            jni.JniCallType.objectType,
            [name.reference, value.reference]).object);
  }

  static final _id_removeHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"removeHeader",
      r"(Ljava/lang/String;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder removeHeader(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Removes all headers named {@code name} on this builder.
  Request_Builder removeHeader(
    jni.JString name,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_removeHeader,
            jni.JniCallType.objectType, [name.reference]).object);
  }

  static final _id_headers = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"headers", r"(Lokhttp3/Headers;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder headers(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Removes all headers on this builder and adds {@code headers}.
  Request_Builder headers(
    headers_.Headers headers,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_headers, jni.JniCallType.objectType,
            [headers.reference]).object);
  }

  static final _id_cacheControl = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"cacheControl",
      r"(Lokhttp3/CacheControl;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder cacheControl(okhttp3.CacheControl cacheControl)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets this request's {@code Cache-Control} header, replacing any cache control headers already
  /// present. If {@code cacheControl} doesn't define any directives, this clears this request's
  /// cache-control headers.
  Request_Builder cacheControl(
    jni.JObject cacheControl,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_cacheControl,
            jni.JniCallType.objectType, [cacheControl.reference]).object);
  }

  static final _id_get0 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"get", r"()Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder get()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder get0() {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_get0, jni.JniCallType.objectType, []).object);
  }

  static final _id_head = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"head", r"()Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder head()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder head() {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_head, jni.JniCallType.objectType, []).object);
  }

  static final _id_post = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"post", r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder post(okhttp3.RequestBody body)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder post(
    requestbody_.RequestBody body,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_post, jni.JniCallType.objectType,
            [body.reference]).object);
  }

  static final _id_delete = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"delete", r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder delete(okhttp3.RequestBody body)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder delete(
    requestbody_.RequestBody body,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_delete, jni.JniCallType.objectType,
            [body.reference]).object);
  }

  static final _id_delete1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"delete", r"()Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder delete()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder delete1() {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_delete1, jni.JniCallType.objectType, []).object);
  }

  static final _id_put = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"put", r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder put(okhttp3.RequestBody body)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder put(
    requestbody_.RequestBody body,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_put, jni.JniCallType.objectType,
            [body.reference]).object);
  }

  static final _id_patch = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"patch", r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder patch(okhttp3.RequestBody body)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder patch(
    requestbody_.RequestBody body,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_patch, jni.JniCallType.objectType,
            [body.reference]).object);
  }

  static final _id_method = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"method",
      r"(Ljava/lang/String;Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder method(java.lang.String method, okhttp3.RequestBody body)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder method(
    jni.JString method,
    requestbody_.RequestBody body,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_method, jni.JniCallType.objectType,
            [method.reference, body.reference]).object);
  }

  static final _id_tag = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"tag", r"(Ljava/lang/Object;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder tag(java.lang.Object tag)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Attaches {@code tag} to the request using {@code Object.class} as a key.
  Request_Builder tag(
    jni.JObject tag,
  ) {
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_tag, jni.JniCallType.objectType,
            [tag.reference]).object);
  }

  static final _id_tag1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"tag",
      r"(Ljava/lang/Class;Ljava/lang/Object;)Lokhttp3/Request$Builder;");

  /// from: public okhttp3.Request.Builder tag(java.lang.Class<? super T> type, T tag)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Attaches {@code tag} to the request using {@code type} as a key. Tags can be read from a
  /// request using Request\#tag. Use null to remove any existing tag assigned for {@code
  /// type}.
  ///
  /// Use this API to attach timing, debugging, or other application data to a request so that
  /// you may read it in interceptors, event listeners, or callbacks.
  Request_Builder tag1<$T extends jni.JObject>(
    jni.JObject type0,
    $T tag, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      tag.$type,
    ]) as jni.JObjType<$T>;
    return const $Request_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_tag1, jni.JniCallType.objectType,
            [type0.reference, tag.reference]).object);
  }

  static final _id_build = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"build", r"()Lokhttp3/Request;");

  /// from: public okhttp3.Request build()
  /// The returned object must be released after use, by calling the [release] method.
  Request build() {
    return const $RequestType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
  }
}

final class $Request_BuilderType extends jni.JObjType<Request_Builder> {
  const $Request_BuilderType();

  @override
  String get signature => r"Lokhttp3/Request$Builder;";

  @override
  Request_Builder fromRef(jni.JObjectPtr ref) => Request_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Request_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Request_BuilderType) &&
        other is $Request_BuilderType;
  }
}
