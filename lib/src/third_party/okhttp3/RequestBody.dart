// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "MediaType.dart" as mediatype_;

/// from: okhttp3.RequestBody
class RequestBody extends jni.JObject {
  @override
  late final jni.JObjType<RequestBody> $type = type;

  RequestBody.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/RequestBody");

  /// The type which includes information such as the signature of this class.
  static const type = $RequestBodyType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory RequestBody() {
    return RequestBody.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_contentType = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"contentType", r"()Lokhttp3/MediaType;");

  /// from: public abstract okhttp3.MediaType contentType()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the Content-Type header for this body.
  mediatype_.MediaType contentType() {
    return const mediatype_.$MediaTypeType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_contentType, jni.JniCallType.objectType, []).object);
  }

  static final _id_contentLength = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"contentLength", r"()J");

  /// from: public long contentLength()
  ///
  /// Returns the number of bytes that will be written to {@code sink} in a call to \#writeTo,
  /// or -1 if that count is unknown.
  int contentLength() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_contentLength, jni.JniCallType.longType, []).long;
  }

  static final _id_writeTo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeTo", r"(Lokio/BufferedSink;)V");

  /// from: public abstract void writeTo(okio.BufferedSink sink)
  ///
  /// Writes the content of this request to {@code sink}.
  void writeTo(
    jni.JObject sink,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_writeTo,
        jni.JniCallType.voidType, [sink.reference]).check();
  }

  static final _id_isDuplex =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isDuplex", r"()Z");

  /// from: public boolean isDuplex()
  ///
  /// A duplex request body is special in how it is <strong>transmitted</strong> on the network and
  /// in the <strong>API contract</strong> between OkHttp and the application.
  ///
  /// This method returns false unless it is overridden by a subclass.
  ///
  /// <h3>Duplex Transmission</h3>
  ///
  /// With regular HTTP calls the request always completes sending before the response may begin
  /// receiving. With duplex the request and response may be interleaved! That is, request body bytes
  /// may be sent after response headers or body bytes have been received.
  ///
  /// Though any call may be initiated as a duplex call, only web servers that are specially
  /// designed for this nonstandard interaction will use it. As of 2019-01, the only widely-used
  /// implementation of this pattern is <a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md">gRPC</a>.
  ///
  /// Because the encoding of interleaved data is not well-defined for HTTP/1, duplex request
  /// bodies may only be used with HTTP/2. Calls to HTTP/1 servers will fail before the HTTP request
  /// is transmitted. If you cannot ensure that your client and server both support HTTP/2, do not
  /// use this feature.
  ///
  /// Duplex APIs
  ///
  ///
  /// With regular request bodies it is not legal to write bytes to the sink passed to RequestBody\#writeTo after that method returns. For duplex requests bodies that condition is
  /// lifted. Such writes occur on an application-provided thread and may occur concurrently with
  /// reads of the ResponseBody. For duplex request bodies, \#writeTo should return
  /// quickly, possibly by handing off the provided request body to another thread to perform
  /// writing.
  bool isDuplex() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isDuplex, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isOneShot =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isOneShot", r"()Z");

  /// from: public boolean isOneShot()
  ///
  /// Returns true if this body expects at most one call to \#writeTo and can be transmitted
  /// at most once. This is typically used when writing the request body is destructive and it is not
  /// possible to recreate the request body after it has been sent.
  ///
  /// This method returns false unless it is overridden by a subclass.
  ///
  /// By default OkHttp will attempt to retransmit request bodies when the original request fails
  /// due to a stale connection, a client timeout (HTTP 408), a satisfied authorization challenge
  /// (HTTP 401 and 407), or a retryable server failure (HTTP 503 with a {@code Retry-After: 0}
  /// header).
  bool isOneShot() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isOneShot, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_create = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/RequestBody;");

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType contentType, java.lang.String content)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
  /// and lacks a charset, this will use UTF-8.
  static RequestBody create(
    mediatype_.MediaType contentType,
    jni.JString content,
  ) {
    return const $RequestBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create,
            jni.JniCallType.objectType,
            [contentType.reference, content.reference]).object);
  }

  static final _id_create1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/RequestBody;");

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType contentType, okio.ByteString content)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a new request body that transmits {@code content}.
  static RequestBody create1(
    mediatype_.MediaType contentType,
    jni.JObject content,
  ) {
    return const $RequestBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create1,
            jni.JniCallType.objectType,
            [contentType.reference, content.reference]).object);
  }

  static final _id_create2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;[B)Lokhttp3/RequestBody;");

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType contentType, byte[] content)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a new request body that transmits {@code content}.
  static RequestBody create2(
    mediatype_.MediaType contentType,
    jni.JArray<jni.jbyte> content,
  ) {
    return const $RequestBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create2,
            jni.JniCallType.objectType,
            [contentType.reference, content.reference]).object);
  }

  static final _id_create3 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;[BII)Lokhttp3/RequestBody;");

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType contentType, byte[] content, int offset, int byteCount)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a new request body that transmits {@code content}.
  static RequestBody create3(
    mediatype_.MediaType contentType,
    jni.JArray<jni.jbyte> content,
    int offset,
    int byteCount,
  ) {
    return const $RequestBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference, _id_create3, jni.JniCallType.objectType, [
      contentType.reference,
      content.reference,
      jni.JValueInt(offset),
      jni.JValueInt(byteCount)
    ]).object);
  }

  static final _id_create4 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Ljava/io/File;)Lokhttp3/RequestBody;");

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType contentType, java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a new request body that transmits the content of {@code file}.
  static RequestBody create4(
    mediatype_.MediaType contentType,
    jni.JObject file,
  ) {
    return const $RequestBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create4,
            jni.JniCallType.objectType,
            [contentType.reference, file.reference]).object);
  }
}

final class $RequestBodyType extends jni.JObjType<RequestBody> {
  const $RequestBodyType();

  @override
  String get signature => r"Lokhttp3/RequestBody;";

  @override
  RequestBody fromRef(jni.JObjectPtr ref) => RequestBody.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestBodyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestBodyType) && other is $RequestBodyType;
  }
}
