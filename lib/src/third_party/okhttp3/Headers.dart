// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: okhttp3.Headers
///
/// The header fields of a single HTTP message. Values are uninterpreted strings; use {@code Request}
/// and {@code Response} for interpreted headers. This class maintains the order of the header fields
/// within the HTTP message.
///
/// This class tracks header values line-by-line. A field with multiple comma- separated values on
/// the same line will be treated as a field with a single value by this class. It is the caller's
/// responsibility to detect and split on commas if their field permits multiple values. This
/// simplifies use of single-valued fields whose values routinely contain commas, such as cookies or
/// dates.
///
/// This class trims whitespace from values. It never returns values with leading or trailing
/// whitespace.
///
/// Instances of this class are immutable. Use Builder to create instances.
class Headers extends jni.JObject {
  @override
  late final jni.JObjType<Headers> $type = type;

  Headers.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Headers");

  /// The type which includes information such as the signature of this class.
  static const type = $HeadersType();
  static final _id_get0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"get", r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String get(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the last value corresponding to the specified field, or null.
  jni.JString get0(
    jni.JString name,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get0,
        jni.JniCallType.objectType,
        [name.reference]).object);
  }

  static final _id_getDate = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getDate", r"(Ljava/lang/String;)Ljava/util/Date;");

  /// from: public java.util.Date getDate(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
  /// either the field is absent or cannot be parsed as a date.
  jni.JObject getDate(
    jni.JString name,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getDate,
        jni.JniCallType.objectType,
        [name.reference]).object);
  }

  static final _id_getInstant = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"getInstant",
      r"(Ljava/lang/String;)Ljava/time/Instant;");

  /// from: public java.time.Instant getInstant(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
  /// either the field is absent or cannot be parsed as a date.
  jni.JObject getInstant(
    jni.JString name,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getInstant,
        jni.JniCallType.objectType,
        [name.reference]).object);
  }

  static final _id_size =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"size", r"()I");

  /// from: public int size()
  ///
  /// Returns the number of field values.
  int size() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_size, jni.JniCallType.intType, []).integer;
  }

  static final _id_name = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"name", r"(I)Ljava/lang/String;");

  /// from: public java.lang.String name(int index)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the field at {@code position}.
  jni.JString name(
    int index,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_name,
        jni.JniCallType.objectType,
        [jni.JValueInt(index)]).object);
  }

  static final _id_value = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"value", r"(I)Ljava/lang/String;");

  /// from: public java.lang.String value(int index)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the value at {@code index}.
  jni.JString value(
    int index,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_value,
        jni.JniCallType.objectType,
        [jni.JValueInt(index)]).object);
  }

  static final _id_names = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"names", r"()Ljava/util/Set;");

  /// from: public java.util.Set<java.lang.String> names()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns an immutable case-insensitive set of header names.
  jni.JSet<jni.JString> names() {
    return const jni.JSetType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_names, jni.JniCallType.objectType, []).object);
  }

  static final _id_values = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"values", r"(Ljava/lang/String;)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> values(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns an immutable list of the header values for {@code name}.
  jni.JList<jni.JString> values(
    jni.JString name,
  ) {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_values, jni.JniCallType.objectType,
            [name.reference]).object);
  }

  static final _id_byteCount =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"byteCount", r"()J");

  /// from: public long byteCount()
  ///
  /// Returns the number of bytes required to encode these headers using HTTP/1.1. This is also the
  /// approximate size of HTTP/2 headers before they are compressed with HPACK. This value is
  /// intended to be used as a metric: smaller headers are more efficient to encode and transmit.
  int byteCount() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_byteCount, jni.JniCallType.longType, []).long;
  }

  static final _id_newBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newBuilder", r"()Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers.Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder newBuilder() {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_newBuilder, jni.JniCallType.objectType, []).object);
  }

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object other)
  ///
  /// Returns true if {@code other} is a {@code Headers} object with the same headers, with the same
  /// casing, in the same order. Note that two headers instances may be <i>semantically</i> equal
  /// but not equal according to this method. In particular, none of the following sets of headers
  /// are equal according to this method: <pre>   {@code
  ///
  ///   1. Original
  ///   Content-Type: text/html
  ///   Content-Length: 50
  ///
  ///   2. Different order
  ///   Content-Length: 50
  ///   Content-Type: text/html
  ///
  ///   3. Different case
  ///   content-type: text/html
  ///   content-length: 50
  ///
  ///   4. Different values
  ///   Content-Type: text/html
  ///   Content-Length: 050
  /// }</pre>
  ///
  /// Applications that require semantically equal headers should convert them into a canonical form
  /// before comparing them for equality.
  bool equals1(
    jni.JObject other,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [other.reference]).boolean;
  }

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hashCode", r"()I");

  /// from: public int hashCode()
  int hashCode1() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_toMultimap = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toMultimap", r"()Ljava/util/Map;");

  /// from: public java.util.Map<java.lang.String,java.util.List<java.lang.String>> toMultimap()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JMap<jni.JString, jni.JList<jni.JString>> toMultimap() {
    return const jni.JMapType(
            jni.JStringType(), jni.JListType(jni.JStringType()))
        .fromRef(jni.Jni.accessors.callMethodWithArgs(
            reference, _id_toMultimap, jni.JniCallType.objectType, []).object);
  }

  static final _id_of = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"of", r"([Ljava/lang/String;)Lokhttp3/Headers;");

  /// from: static public okhttp3.Headers of(java.lang.String[] namesAndValues)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns headers for the alternating header names and values. There must be an even number of
  /// arguments, and they must alternate between header names and values.
  static Headers of(
    jni.JArray<jni.JString> namesAndValues,
  ) {
    return const $HeadersType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_of,
            jni.JniCallType.objectType, [namesAndValues.reference]).object);
  }

  static final _id_of1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"of", r"(Ljava/util/Map;)Lokhttp3/Headers;");

  /// from: static public okhttp3.Headers of(java.util.Map<java.lang.String,java.lang.String> headers)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns headers for the header names and values in the Map.
  static Headers of1(
    jni.JMap<jni.JString, jni.JString> headers,
  ) {
    return const $HeadersType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_of1,
            jni.JniCallType.objectType, [headers.reference]).object);
  }
}

final class $HeadersType extends jni.JObjType<Headers> {
  const $HeadersType();

  @override
  String get signature => r"Lokhttp3/Headers;";

  @override
  Headers fromRef(jni.JObjectPtr ref) => Headers.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($HeadersType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HeadersType) && other is $HeadersType;
  }
}

/// from: okhttp3.Headers$Builder
class Headers_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Headers_Builder> $type = type;

  Headers_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Headers$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $Headers_BuilderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Headers_Builder() {
    return Headers_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_add = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"add", r"(Ljava/lang/String;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers.Builder add(java.lang.String line)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add an header line containing a field name, a literal colon, and a value.
  Headers_Builder add(
    jni.JString line,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_add, jni.JniCallType.objectType,
            [line.reference]).object);
  }

  static final _id_add1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"add",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers.Builder add(java.lang.String name, java.lang.String value)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add a header with the specified name and value. Does validation of header names and values.
  Headers_Builder add1(
    jni.JString name,
    jni.JString value,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_add1, jni.JniCallType.objectType,
            [name.reference, value.reference]).object);
  }

  static final _id_addUnsafeNonAscii = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addUnsafeNonAscii",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers.Builder addUnsafeNonAscii(java.lang.String name, java.lang.String value)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add a header with the specified name and value. Does validation of header names, allowing
  /// non-ASCII values.
  Headers_Builder addUnsafeNonAscii(
    jni.JString name,
    jni.JString value,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_addUnsafeNonAscii,
            jni.JniCallType.objectType,
            [name.reference, value.reference]).object);
  }

  static final _id_addAll = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"addAll", r"(Lokhttp3/Headers;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers.Builder addAll(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Adds all headers from an existing collection.
  Headers_Builder addAll(
    Headers headers,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addAll, jni.JniCallType.objectType,
            [headers.reference]).object);
  }

  static final _id_add2 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"add", r"(Ljava/lang/String;Ljava/util/Date;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers.Builder add(java.lang.String name, java.util.Date value)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add a header with the specified name and formatted date. Does validation of header names and
  /// value.
  Headers_Builder add2(
    jni.JString name,
    jni.JObject value,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_add2, jni.JniCallType.objectType,
            [name.reference, value.reference]).object);
  }

  static final _id_add3 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"add",
      r"(Ljava/lang/String;Ljava/time/Instant;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers.Builder add(java.lang.String name, java.time.Instant value)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add a header with the specified name and formatted instant. Does validation of header names
  /// and value.
  Headers_Builder add3(
    jni.JString name,
    jni.JObject value,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_add3, jni.JniCallType.objectType,
            [name.reference, value.reference]).object);
  }

  static final _id_set0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"set", r"(Ljava/lang/String;Ljava/util/Date;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers.Builder set(java.lang.String name, java.util.Date value)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set a field with the specified date. If the field is not found, it is added. If the field is
  /// found, the existing values are replaced.
  Headers_Builder set0(
    jni.JString name,
    jni.JObject value,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_set0, jni.JniCallType.objectType,
            [name.reference, value.reference]).object);
  }

  static final _id_set1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"set",
      r"(Ljava/lang/String;Ljava/time/Instant;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers.Builder set(java.lang.String name, java.time.Instant value)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set a field with the specified instant. If the field is not found, it is added. If the field
  /// is found, the existing values are replaced.
  Headers_Builder set1(
    jni.JString name,
    jni.JObject value,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_set1, jni.JniCallType.objectType,
            [name.reference, value.reference]).object);
  }

  static final _id_removeAll = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"removeAll", r"(Ljava/lang/String;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers.Builder removeAll(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder removeAll(
    jni.JString name,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_removeAll,
            jni.JniCallType.objectType, [name.reference]).object);
  }

  static final _id_set2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"set",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Headers$Builder;");

  /// from: public okhttp3.Headers.Builder set(java.lang.String name, java.lang.String value)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set a field with the specified value. If the field is not found, it is added. If the field is
  /// found, the existing values are replaced.
  Headers_Builder set2(
    jni.JString name,
    jni.JString value,
  ) {
    return const $Headers_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_set2, jni.JniCallType.objectType,
            [name.reference, value.reference]).object);
  }

  static final _id_get0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"get", r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String get(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Equivalent to {@code build().get(name)}, but potentially faster.
  jni.JString get0(
    jni.JString name,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get0,
        jni.JniCallType.objectType,
        [name.reference]).object);
  }

  static final _id_build = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"build", r"()Lokhttp3/Headers;");

  /// from: public okhttp3.Headers build()
  /// The returned object must be released after use, by calling the [release] method.
  Headers build() {
    return const $HeadersType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
  }
}

final class $Headers_BuilderType extends jni.JObjType<Headers_Builder> {
  const $Headers_BuilderType();

  @override
  String get signature => r"Lokhttp3/Headers$Builder;";

  @override
  Headers_Builder fromRef(jni.JObjectPtr ref) => Headers_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Headers_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Headers_BuilderType) &&
        other is $Headers_BuilderType;
  }
}
