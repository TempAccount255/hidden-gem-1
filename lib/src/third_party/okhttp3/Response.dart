// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "Request.dart" as request_;

import "Headers.dart" as headers_;

import "ResponseBody.dart" as responsebody_;

/// from: okhttp3.Response
///
/// An HTTP response. Instances of this class are not immutable: the response body is a one-shot
/// value that may be consumed only once and then closed. All other properties are immutable.
///
/// This class implements Closeable. Closing it simply closes its response body. See
/// ResponseBody for an explanation and examples.
class Response extends jni.JObject {
  @override
  late final jni.JObjType<Response> $type = type;

  Response.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Response");

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseType();
  static final _id_request = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"request", r"()Lokhttp3/Request;");

  /// from: public okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The wire-level request that initiated this HTTP response. This is not necessarily the same
  /// request issued by the application:
  ///
  /// <ul>
  ///     <li>It may be transformed by the HTTP client. For example, the client may copy headers like
  ///         {@code Content-Length} from the request body.
  ///     <li>It may be the request generated in response to an HTTP redirect or authentication
  ///         challenge. In this case the request URL may be different than the initial request URL.
  /// </ul>
  request_.Request request() {
    return const request_.$RequestType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_request, jni.JniCallType.objectType, []).object);
  }

  static final _id_protocol = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protocol", r"()Lokhttp3/Protocol;");

  /// from: public okhttp3.Protocol protocol()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the HTTP protocol, such as Protocol\#HTTP_1_1 or Protocol\#HTTP_1_0.
  jni.JObject protocol() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_protocol, jni.JniCallType.objectType, []).object);
  }

  static final _id_code =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"code", r"()I");

  /// from: public int code()
  ///
  /// Returns the HTTP status code.
  int code() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_code, jni.JniCallType.intType, []).integer;
  }

  static final _id_isSuccessful = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isSuccessful", r"()Z");

  /// from: public boolean isSuccessful()
  ///
  /// Returns true if the code is in [200..300), which means the request was successfully received,
  /// understood, and accepted.
  bool isSuccessful() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isSuccessful, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_message = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"message", r"()Ljava/lang/String;");

  /// from: public java.lang.String message()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the HTTP status message.
  jni.JString message() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_message, jni.JniCallType.objectType, []).object);
  }

  static final _id_handshake = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"handshake", r"()Lokhttp3/Handshake;");

  /// from: public okhttp3.Handshake handshake()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the TLS handshake of the connection that carried this response, or null if the response
  /// was received without TLS.
  jni.JObject handshake() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_handshake, jni.JniCallType.objectType, []).object);
  }

  static final _id_headers = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"headers", r"(Ljava/lang/String;)Ljava/util/List;");

  /// from: public java.util.List<java.lang.String> headers(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> headers(
    jni.JString name,
  ) {
    return const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_headers, jni.JniCallType.objectType,
            [name.reference]).object);
  }

  static final _id_header = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"header", r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String header(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header(
    jni.JString name,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_header,
        jni.JniCallType.objectType,
        [name.reference]).object);
  }

  static final _id_header1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"header", r"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: public java.lang.String header(java.lang.String name, java.lang.String defaultValue)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header1(
    jni.JString name,
    jni.JString defaultValue,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_header1,
        jni.JniCallType.objectType,
        [name.reference, defaultValue.reference]).object);
  }

  static final _id_headers1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"headers", r"()Lokhttp3/Headers;");

  /// from: public okhttp3.Headers headers()
  /// The returned object must be released after use, by calling the [release] method.
  headers_.Headers headers1() {
    return const headers_.$HeadersType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_headers1, jni.JniCallType.objectType, []).object);
  }

  static final _id_trailers = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"trailers", r"()Lokhttp3/Headers;");

  /// from: public okhttp3.Headers trailers()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the trailers after the HTTP response, which may be empty. It is an error to call this
  /// before the entire HTTP response body has been consumed.
  headers_.Headers trailers() {
    return const headers_.$HeadersType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_trailers, jni.JniCallType.objectType, []).object);
  }

  static final _id_peekBody = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"peekBody", r"(J)Lokhttp3/ResponseBody;");

  /// from: public okhttp3.ResponseBody peekBody(long byteCount)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Peeks up to {@code byteCount} bytes from the response body and returns them as a new response
  /// body. If fewer than {@code byteCount} bytes are in the response body, the full response body is
  /// returned. If more than {@code byteCount} bytes are in the response body, the returned value
  /// will be truncated to {@code byteCount} bytes.
  ///
  /// It is an error to call this method after the body has been consumed.
  ///
  /// <strong>Warning:</strong> this method loads the requested bytes into memory. Most
  /// applications should set a modest limit on {@code byteCount}, such as 1 MiB.
  responsebody_.ResponseBody peekBody(
    int byteCount,
  ) {
    return const responsebody_.$ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_peekBody, jni.JniCallType.objectType,
            [byteCount]).object);
  }

  static final _id_body = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"body", r"()Lokhttp3/ResponseBody;");

  /// from: public okhttp3.ResponseBody body()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a non-null value if this response was passed to Callback\#onResponse or returned
  /// from Call\#execute(). Response bodies must be {@linkplain ResponseBody closed} and may
  /// be consumed only once.
  ///
  /// This always returns null on responses returned from \#cacheResponse, \#networkResponse, and \#priorResponse().
  responsebody_.ResponseBody body() {
    return const responsebody_.$ResponseBodyType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_body, jni.JniCallType.objectType, []).object);
  }

  static final _id_newBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newBuilder", r"()Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder newBuilder() {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_newBuilder, jni.JniCallType.objectType, []).object);
  }

  static final _id_isRedirect =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isRedirect", r"()Z");

  /// from: public boolean isRedirect()
  ///
  /// Returns true if this response redirects to another resource.
  bool isRedirect() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isRedirect, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_networkResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"networkResponse", r"()Lokhttp3/Response;");

  /// from: public okhttp3.Response networkResponse()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the raw response received from the network. Will be null if this response didn't use
  /// the network, such as when the response is fully cached. The body of the returned response
  /// should not be read.
  Response networkResponse() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_networkResponse, jni.JniCallType.objectType, []).object);
  }

  static final _id_cacheResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"cacheResponse", r"()Lokhttp3/Response;");

  /// from: public okhttp3.Response cacheResponse()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the raw response received from the cache. Will be null if this response didn't use the
  /// cache. For conditional get requests the cache response and network response may both be
  /// non-null. The body of the returned response should not be read.
  Response cacheResponse() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cacheResponse, jni.JniCallType.objectType, []).object);
  }

  static final _id_priorResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"priorResponse", r"()Lokhttp3/Response;");

  /// from: public okhttp3.Response priorResponse()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the response for the HTTP redirect or authorization challenge that triggered this
  /// response, or null if this response wasn't triggered by an automatic retry. The body of the
  /// returned response should not be read because it has already been consumed by the redirecting
  /// client.
  Response priorResponse() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_priorResponse, jni.JniCallType.objectType, []).object);
  }

  static final _id_challenges = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"challenges", r"()Ljava/util/List;");

  /// from: public java.util.List<okhttp3.Challenge> challenges()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the RFC 7235 authorization challenges appropriate for this response's code. If the
  /// response code is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the
  /// response code is 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges.
  /// Otherwise this returns an empty list of challenges.
  ///
  /// If a challenge uses the {@code token68} variant instead of auth params, there is exactly one
  /// auth param in the challenge at key {@code null}. Invalid headers and challenges are ignored.
  /// No semantic validation is done, for example that {@code Basic} auth must have a {@code realm}
  /// auth param, this is up to the caller that interprets these challenges.
  jni.JList<jni.JObject> challenges() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_challenges, jni.JniCallType.objectType, []).object);
  }

  static final _id_cacheControl = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"cacheControl", r"()Lokhttp3/CacheControl;");

  /// from: public okhttp3.CacheControl cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the cache control directives for this response. This is never null, even if this
  /// response contains no {@code Cache-Control} header.
  jni.JObject cacheControl() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cacheControl, jni.JniCallType.objectType, []).object);
  }

  static final _id_sentRequestAtMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"sentRequestAtMillis", r"()J");

  /// from: public long sentRequestAtMillis()
  ///
  /// Returns a {@linkplain System\#currentTimeMillis() timestamp} taken immediately before OkHttp
  /// transmitted the initiating request over the network. If this response is being served from the
  /// cache then this is the timestamp of the original request.
  int sentRequestAtMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_sentRequestAtMillis, jni.JniCallType.longType, []).long;
  }

  static final _id_receivedResponseAtMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"receivedResponseAtMillis", r"()J");

  /// from: public long receivedResponseAtMillis()
  ///
  /// Returns a {@linkplain System\#currentTimeMillis() timestamp} taken immediately after OkHttp
  /// received this response's headers from the network. If this response is being served from the
  /// cache then this is the timestamp of the original response.
  int receivedResponseAtMillis() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_receivedResponseAtMillis, jni.JniCallType.longType, []).long;
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  ///
  /// Closes the response body. Equivalent to {@code body().close()}.
  ///
  /// It is an error to close a response that is not eligible for a body. This includes the
  /// responses returned from \#cacheResponse, \#networkResponse, and \#priorResponse().
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }
}

final class $ResponseType extends jni.JObjType<Response> {
  const $ResponseType();

  @override
  String get signature => r"Lokhttp3/Response;";

  @override
  Response fromRef(jni.JObjectPtr ref) => Response.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseType) && other is $ResponseType;
  }
}

/// from: okhttp3.Response$Builder
class Response_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Response_Builder> $type = type;

  Response_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/Response$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $Response_BuilderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Response_Builder() {
    return Response_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_request = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"request", r"(Lokhttp3/Request;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder request(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder request(
    request_.Request request,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_request, jni.JniCallType.objectType,
            [request.reference]).object);
  }

  static final _id_protocol = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"protocol", r"(Lokhttp3/Protocol;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder protocol(okhttp3.Protocol protocol)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder protocol(
    jni.JObject protocol,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_protocol, jni.JniCallType.objectType,
            [protocol.reference]).object);
  }

  static final _id_code = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"code", r"(I)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder code(int code)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder code(
    int code,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_code, jni.JniCallType.objectType,
            [jni.JValueInt(code)]).object);
  }

  static final _id_message = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"message", r"(Ljava/lang/String;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder message(java.lang.String message)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder message(
    jni.JString message,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_message, jni.JniCallType.objectType,
            [message.reference]).object);
  }

  static final _id_handshake = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"handshake", r"(Lokhttp3/Handshake;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder handshake(okhttp3.Handshake handshake)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder handshake(
    jni.JObject handshake,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_handshake,
            jni.JniCallType.objectType, [handshake.reference]).object);
  }

  static final _id_header = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"header",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder header(java.lang.String name, java.lang.String value)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the header named {@code name} to {@code value}. If this request already has any headers
  /// with that name, they are all replaced.
  Response_Builder header(
    jni.JString name,
    jni.JString value,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_header, jni.JniCallType.objectType,
            [name.reference, value.reference]).object);
  }

  static final _id_addHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addHeader",
      r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder addHeader(java.lang.String name, java.lang.String value)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
  /// headers like "Set-Cookie".
  Response_Builder addHeader(
    jni.JString name,
    jni.JString value,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_addHeader,
            jni.JniCallType.objectType,
            [name.reference, value.reference]).object);
  }

  static final _id_removeHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"removeHeader",
      r"(Ljava/lang/String;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder removeHeader(java.lang.String name)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Removes all headers named {@code name} on this builder.
  Response_Builder removeHeader(
    jni.JString name,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_removeHeader,
            jni.JniCallType.objectType, [name.reference]).object);
  }

  static final _id_headers = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"headers", r"(Lokhttp3/Headers;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder headers(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Removes all headers on this builder and adds {@code headers}.
  Response_Builder headers(
    headers_.Headers headers,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_headers, jni.JniCallType.objectType,
            [headers.reference]).object);
  }

  static final _id_body = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"body", r"(Lokhttp3/ResponseBody;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder body(okhttp3.ResponseBody body)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder body(
    responsebody_.ResponseBody body,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_body, jni.JniCallType.objectType,
            [body.reference]).object);
  }

  static final _id_networkResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"networkResponse",
      r"(Lokhttp3/Response;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder networkResponse(okhttp3.Response networkResponse)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder networkResponse(
    Response networkResponse,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_networkResponse,
            jni.JniCallType.objectType, [networkResponse.reference]).object);
  }

  static final _id_cacheResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"cacheResponse",
      r"(Lokhttp3/Response;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder cacheResponse(okhttp3.Response cacheResponse)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder cacheResponse(
    Response cacheResponse,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_cacheResponse,
            jni.JniCallType.objectType, [cacheResponse.reference]).object);
  }

  static final _id_priorResponse = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"priorResponse",
      r"(Lokhttp3/Response;)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder priorResponse(okhttp3.Response priorResponse)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder priorResponse(
    Response priorResponse,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_priorResponse,
            jni.JniCallType.objectType, [priorResponse.reference]).object);
  }

  static final _id_sentRequestAtMillis = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"sentRequestAtMillis",
      r"(J)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder sentRequestAtMillis(long sentRequestAtMillis)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder sentRequestAtMillis(
    int sentRequestAtMillis,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_sentRequestAtMillis,
            jni.JniCallType.objectType, [sentRequestAtMillis]).object);
  }

  static final _id_receivedResponseAtMillis = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"receivedResponseAtMillis",
      r"(J)Lokhttp3/Response$Builder;");

  /// from: public okhttp3.Response.Builder receivedResponseAtMillis(long receivedResponseAtMillis)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder receivedResponseAtMillis(
    int receivedResponseAtMillis,
  ) {
    return const $Response_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_receivedResponseAtMillis,
            jni.JniCallType.objectType, [receivedResponseAtMillis]).object);
  }

  static final _id_build = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"build", r"()Lokhttp3/Response;");

  /// from: public okhttp3.Response build()
  /// The returned object must be released after use, by calling the [release] method.
  Response build() {
    return const $ResponseType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
  }
}

final class $Response_BuilderType extends jni.JObjType<Response_Builder> {
  const $Response_BuilderType();

  @override
  String get signature => r"Lokhttp3/Response$Builder;";

  @override
  Response_Builder fromRef(jni.JObjectPtr ref) => Response_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Response_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Response_BuilderType) &&
        other is $Response_BuilderType;
  }
}
