// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "MediaType.dart" as mediatype_;

import "../okio/BufferedSource.dart" as bufferedsource_;

/// from: okhttp3.ResponseBody
///
/// A one-shot stream from the origin server to the client application with the raw bytes of the
/// response body. Each response body is supported by an active connection to the webserver. This
/// imposes both obligations and limits on the client application.
///
/// <h3>The response body must be closed.</h3>
///
/// Each response body is backed by a limited resource like a socket (live network responses) or
/// an open file (for cached responses). Failing to close the response body will leak resources and
/// may ultimately cause the application to slow down or crash.
///
/// Both this class and Response implement Closeable. Closing a response simply
/// closes its response body. If you invoke Call\#execute() or implement Callback\#onResponse you must close this body by calling any of the following methods:
///
/// <ul>
///   <li>Response.close()</li>
///   <li>Response.body().close()</li>
///   <li>Response.body().source().close()</li>
///   <li>Response.body().charStream().close()</li>
///   <li>Response.body().byteStream().close()</li>
///   <li>Response.body().bytes()</li>
///   <li>Response.body().string()</li>
/// </ul>
///
/// There is no benefit to invoking multiple {@code close()} methods for the same response body.
///
/// For synchronous calls, the easiest way to make sure a response body is closed is with a {@code
/// try} block. With this structure the compiler inserts an implicit {@code finally} clause that
/// calls {@code close()} for you.
///
/// <pre>   {@code
///
///   Call call = client.newCall(request);
///   try (Response response = call.execute()) {
///     ... // Use the response.
///   }
/// }</pre>
///
/// You can use a similar block for asynchronous calls: <pre>   {@code
///
///   Call call = client.newCall(request);
///   call.enqueue(new Callback() {
///     public void onResponse(Call call, Response response) throws IOException {
///       try (ResponseBody responseBody = response.body()) {
///         ... // Use the response.
///       }
///     }
///
///     public void onFailure(Call call, IOException e) {
///       ... // Handle the failure.
///     }
///   });
/// }</pre>
///
/// These examples will not work if you're consuming the response body on another thread. In such
/// cases the consuming thread must call \#close when it has finished reading the response
/// body.
///
/// <h3>The response body can be consumed only once.</h3>
///
/// This class may be used to stream very large responses. For example, it is possible to use this
/// class to read a response that is larger than the entire memory allocated to the current process.
/// It can even stream a response larger than the total storage on the current device, which is a
/// common requirement for video streaming applications.
///
/// Because this class does not buffer the full response in memory, the application may not
/// re-read the bytes of the response. Use this one shot to read the entire response into memory with
/// \#bytes() or \#string(). Or stream the response with either \#source(),
/// \#byteStream(), or \#charStream().
class ResponseBody extends jni.JObject {
  @override
  late final jni.JObjType<ResponseBody> $type = type;

  ResponseBody.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/ResponseBody");

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseBodyType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory ResponseBody() {
    return ResponseBody.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_contentType = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"contentType", r"()Lokhttp3/MediaType;");

  /// from: public abstract okhttp3.MediaType contentType()
  /// The returned object must be released after use, by calling the [release] method.
  mediatype_.MediaType contentType() {
    return const mediatype_.$MediaTypeType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_contentType, jni.JniCallType.objectType, []).object);
  }

  static final _id_contentLength = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"contentLength", r"()J");

  /// from: public abstract long contentLength()
  ///
  /// Returns the number of bytes in that will returned by \#bytes, or \#byteStream, or
  /// -1 if unknown.
  int contentLength() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_contentLength, jni.JniCallType.longType, []).long;
  }

  static final _id_byteStream = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"byteStream", r"()Ljava/io/InputStream;");

  /// from: public final java.io.InputStream byteStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject byteStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_byteStream, jni.JniCallType.objectType, []).object);
  }

  static final _id_source = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"source", r"()Lokio/BufferedSource;");

  /// from: public abstract okio.BufferedSource source()
  /// The returned object must be released after use, by calling the [release] method.
  bufferedsource_.BufferedSource source() {
    return const bufferedsource_.$BufferedSourceType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_source, jni.JniCallType.objectType, []).object);
  }

  static final _id_bytes =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"bytes", r"()[B");

  /// from: public final byte[] bytes()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the response as a byte array.
  ///
  /// This method loads entire response body into memory. If the response body is very large this
  /// may trigger an OutOfMemoryError. Prefer to stream the response body if this is a
  /// possibility for your response.
  jni.JArray<jni.jbyte> bytes() {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_bytes, jni.JniCallType.objectType, []).object);
  }

  static final _id_charStream = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"charStream", r"()Ljava/io/Reader;");

  /// from: public final java.io.Reader charStream()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the response as a character stream.
  ///
  /// If the response starts with a <a href="https://en.wikipedia.org/wiki/Byte_order_mark">Byte
  /// Order Mark (BOM)</a>, it is consumed and used to determine the charset of the response bytes.
  ///
  /// Otherwise if the response has a Content-Type header that specifies a charset, that is used
  /// to determine the charset of the response bytes.
  ///
  /// Otherwise the response bytes are decoded as UTF-8.
  jni.JObject charStream() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_charStream, jni.JniCallType.objectType, []).object);
  }

  static final _id_string = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"string", r"()Ljava/lang/String;");

  /// from: public final java.lang.String string()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the response as a string.
  ///
  /// If the response starts with a <a href="https://en.wikipedia.org/wiki/Byte_order_mark">Byte
  /// Order Mark (BOM)</a>, it is consumed and used to determine the charset of the response bytes.
  ///
  /// Otherwise if the response has a Content-Type header that specifies a charset, that is used
  /// to determine the charset of the response bytes.
  ///
  /// Otherwise the response bytes are decoded as UTF-8.
  ///
  /// This method loads entire response body into memory. If the response body is very large this
  /// may trigger an OutOfMemoryError. Prefer to stream the response body if this is a
  /// possibility for your response.
  jni.JString string() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_string, jni.JniCallType.objectType, []).object);
  }

  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_create = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/ResponseBody;");

  /// from: static public okhttp3.ResponseBody create(okhttp3.MediaType contentType, java.lang.String content)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a new response body that transmits {@code content}. If {@code contentType} is non-null
  /// and lacks a charset, this will use UTF-8.
  static ResponseBody create(
    mediatype_.MediaType contentType,
    jni.JString content,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create,
            jni.JniCallType.objectType,
            [contentType.reference, content.reference]).object);
  }

  static final _id_create1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;[B)Lokhttp3/ResponseBody;");

  /// from: static public okhttp3.ResponseBody create(okhttp3.MediaType contentType, byte[] content)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a new response body that transmits {@code content}.
  static ResponseBody create1(
    mediatype_.MediaType contentType,
    jni.JArray<jni.jbyte> content,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create1,
            jni.JniCallType.objectType,
            [contentType.reference, content.reference]).object);
  }

  static final _id_create2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/ResponseBody;");

  /// from: static public okhttp3.ResponseBody create(okhttp3.MediaType contentType, okio.ByteString content)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a new response body that transmits {@code content}.
  static ResponseBody create2(
    mediatype_.MediaType contentType,
    jni.JObject content,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create2,
            jni.JniCallType.objectType,
            [contentType.reference, content.reference]).object);
  }

  static final _id_create3 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"create",
      r"(Lokhttp3/MediaType;JLokio/BufferedSource;)Lokhttp3/ResponseBody;");

  /// from: static public okhttp3.ResponseBody create(okhttp3.MediaType contentType, long contentLength, okio.BufferedSource content)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a new response body that transmits {@code content}.
  static ResponseBody create3(
    mediatype_.MediaType contentType,
    int contentLength,
    bufferedsource_.BufferedSource content,
  ) {
    return const $ResponseBodyType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create3,
            jni.JniCallType.objectType,
            [contentType.reference, contentLength, content.reference]).object);
  }
}

final class $ResponseBodyType extends jni.JObjType<ResponseBody> {
  const $ResponseBodyType();

  @override
  String get signature => r"Lokhttp3/ResponseBody;";

  @override
  ResponseBody fromRef(jni.JObjectPtr ref) => ResponseBody.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseBodyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBodyType) &&
        other is $ResponseBodyType;
  }
}
