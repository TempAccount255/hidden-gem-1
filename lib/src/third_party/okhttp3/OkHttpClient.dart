// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "Request.dart" as request_;

import "Call.dart" as call_;

/// from: okhttp3.OkHttpClient
///
/// Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
/// responses.
///
/// <h3>OkHttpClients should be shared</h3>
///
/// OkHttp performs best when you create a single {@code OkHttpClient} instance and reuse it for
/// all of your HTTP calls. This is because each client holds its own connection pool and thread
/// pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a
/// client for each request wastes resources on idle pools.
///
/// Use {@code new OkHttpClient()} to create a shared instance with the default settings:
/// <pre>   {@code
///
///   // The singleton HTTP client.
///   public final OkHttpClient client = new OkHttpClient();
/// }</pre>
///
/// Or use {@code new OkHttpClient.Builder()} to create a shared instance with custom settings:
/// <pre>   {@code
///
///   // The singleton HTTP client.
///   public final OkHttpClient client = new OkHttpClient.Builder()
///       .addInterceptor(new HttpLoggingInterceptor())
///       .cache(new Cache(cacheDir, cacheSize))
///       .build();
/// }</pre>
///
/// <h3>Customize your client with newBuilder()</h3>
///
/// You can customize a shared OkHttpClient instance with \#newBuilder(). This builds a
/// client that shares the same connection pool, thread pools, and configuration. Use the builder
/// methods to configure the derived client for a specific purpose.
///
/// This example shows a call with a short 500 millisecond timeout: <pre>   {@code
///
///   OkHttpClient eagerClient = client.newBuilder()
///       .readTimeout(500, TimeUnit.MILLISECONDS)
///       .build();
///   Response response = eagerClient.newCall(request).execute();
/// }</pre>
///
/// <h3>Shutdown isn't necessary</h3>
///
/// The threads and connections that are held will be released automatically if they remain idle.
/// But if you are writing a application that needs to aggressively release unused resources you may
/// do so.
///
/// Shutdown the dispatcher's executor service with ExecutorService\#shutdown shutdown().
/// This will also cause future calls to the client to be rejected. <pre>   {@code
///
///     client.dispatcher().executorService().shutdown();
/// }</pre>
///
/// Clear the connection pool with ConnectionPool\#evictAll() evictAll(). Note that the
/// connection pool's daemon thread may not exit immediately. <pre>   {@code
///
///     client.connectionPool().evictAll();
/// }</pre>
///
/// If your client has a cache, call Cache\#close close(). Note that it is an error to
/// create calls against a cache that is closed, and doing so will cause the call to crash.
/// <pre>   {@code
///
///     client.cache().close();
/// }</pre>
///
/// OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
/// remain idle.
class OkHttpClient extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient> $type = type;

  OkHttpClient.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/OkHttpClient");

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClientType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient() {
    return OkHttpClient.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_callTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"callTimeoutMillis", r"()I");

  /// from: public int callTimeoutMillis()
  ///
  /// Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
  /// there is for the connect, write, and read actions within a call.
  int callTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_callTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_connectTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"connectTimeoutMillis", r"()I");

  /// from: public int connectTimeoutMillis()
  ///
  /// Default connect timeout (in milliseconds). The default is 10 seconds.
  int connectTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_connectTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_readTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"readTimeoutMillis", r"()I");

  /// from: public int readTimeoutMillis()
  ///
  /// Default read timeout (in milliseconds). The default is 10 seconds.
  int readTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_readTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_writeTimeoutMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"writeTimeoutMillis", r"()I");

  /// from: public int writeTimeoutMillis()
  ///
  /// Default write timeout (in milliseconds). The default is 10 seconds.
  int writeTimeoutMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_writeTimeoutMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_pingIntervalMillis = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"pingIntervalMillis", r"()I");

  /// from: public int pingIntervalMillis()
  ///
  /// Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent.
  int pingIntervalMillis() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_pingIntervalMillis, jni.JniCallType.intType, []).integer;
  }

  static final _id_proxy = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"proxy", r"()Ljava/net/Proxy;");

  /// from: public java.net.Proxy proxy()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxy() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_proxy, jni.JniCallType.objectType, []).object);
  }

  static final _id_proxySelector = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"proxySelector", r"()Ljava/net/ProxySelector;");

  /// from: public java.net.ProxySelector proxySelector()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxySelector() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_proxySelector, jni.JniCallType.objectType, []).object);
  }

  static final _id_cookieJar = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"cookieJar", r"()Lokhttp3/CookieJar;");

  /// from: public okhttp3.CookieJar cookieJar()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cookieJar() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cookieJar, jni.JniCallType.objectType, []).object);
  }

  static final _id_cache = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"cache", r"()Lokhttp3/Cache;");

  /// from: public okhttp3.Cache cache()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cache() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cache, jni.JniCallType.objectType, []).object);
  }

  static final _id_dns = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"dns", r"()Lokhttp3/Dns;");

  /// from: public okhttp3.Dns dns()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dns() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_dns, jni.JniCallType.objectType, []).object);
  }

  static final _id_socketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"socketFactory", r"()Ljavax/net/SocketFactory;");

  /// from: public javax.net.SocketFactory socketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject socketFactory() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_socketFactory, jni.JniCallType.objectType, []).object);
  }

  static final _id_sslSocketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"sslSocketFactory",
      r"()Ljavax/net/ssl/SSLSocketFactory;");

  /// from: public javax.net.ssl.SSLSocketFactory sslSocketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject sslSocketFactory() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_sslSocketFactory,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_hostnameVerifier = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"hostnameVerifier",
      r"()Ljavax/net/ssl/HostnameVerifier;");

  /// from: public javax.net.ssl.HostnameVerifier hostnameVerifier()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject hostnameVerifier() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_hostnameVerifier,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_certificatePinner = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"certificatePinner", r"()Lokhttp3/CertificatePinner;");

  /// from: public okhttp3.CertificatePinner certificatePinner()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject certificatePinner() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_certificatePinner,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_authenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"authenticator", r"()Lokhttp3/Authenticator;");

  /// from: public okhttp3.Authenticator authenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject authenticator() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_authenticator, jni.JniCallType.objectType, []).object);
  }

  static final _id_proxyAuthenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"proxyAuthenticator", r"()Lokhttp3/Authenticator;");

  /// from: public okhttp3.Authenticator proxyAuthenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxyAuthenticator() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_proxyAuthenticator,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_connectionPool = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"connectionPool", r"()Lokhttp3/ConnectionPool;");

  /// from: public okhttp3.ConnectionPool connectionPool()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject connectionPool() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_connectionPool, jni.JniCallType.objectType, []).object);
  }

  static final _id_followSslRedirects = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"followSslRedirects", r"()Z");

  /// from: public boolean followSslRedirects()
  bool followSslRedirects() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_followSslRedirects, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_followRedirects = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"followRedirects", r"()Z");

  /// from: public boolean followRedirects()
  bool followRedirects() {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_followRedirects,
        jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_retryOnConnectionFailure = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"retryOnConnectionFailure", r"()Z");

  /// from: public boolean retryOnConnectionFailure()
  bool retryOnConnectionFailure() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_retryOnConnectionFailure, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_dispatcher = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"dispatcher", r"()Lokhttp3/Dispatcher;");

  /// from: public okhttp3.Dispatcher dispatcher()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dispatcher() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_dispatcher, jni.JniCallType.objectType, []).object);
  }

  static final _id_protocols = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"protocols", r"()Ljava/util/List;");

  /// from: public java.util.List<okhttp3.Protocol> protocols()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> protocols() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_protocols, jni.JniCallType.objectType, []).object);
  }

  static final _id_connectionSpecs = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"connectionSpecs", r"()Ljava/util/List;");

  /// from: public java.util.List<okhttp3.ConnectionSpec> connectionSpecs()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> connectionSpecs() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectionSpecs,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_interceptors = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"interceptors", r"()Ljava/util/List;");

  /// from: public java.util.List<okhttp3.Interceptor> interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns an immutable list of interceptors that observe the full span of each call: from before
  /// the connection is established (if any) until after the response source is selected (either the
  /// origin server, cache, or both).
  jni.JList<jni.JObject> interceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_interceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_networkInterceptors = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"networkInterceptors", r"()Ljava/util/List;");

  /// from: public java.util.List<okhttp3.Interceptor> networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns an immutable list of interceptors that observe a single network request and response.
  /// These interceptors must call Interceptor.Chain\#proceed exactly once: it is an error for
  /// a network interceptor to short-circuit or repeat a network request.
  jni.JList<jni.JObject> networkInterceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_networkInterceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_eventListenerFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"eventListenerFactory",
      r"()Lokhttp3/EventListener$Factory;");

  /// from: public okhttp3.EventListener.Factory eventListenerFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject eventListenerFactory() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_eventListenerFactory,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_newCall = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newCall", r"(Lokhttp3/Request;)Lokhttp3/Call;");

  /// from: public okhttp3.Call newCall(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Prepares the {@code request} to be executed at some point in the future.
  call_.Call newCall(
    request_.Request request,
  ) {
    return const call_.$CallType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_newCall,
        jni.JniCallType.objectType,
        [request.reference]).object);
  }

  static final _id_newWebSocket = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"newWebSocket",
      r"(Lokhttp3/Request;Lokhttp3/WebSocketListener;)Lokhttp3/WebSocket;");

  /// from: public okhttp3.WebSocket newWebSocket(okhttp3.Request request, okhttp3.WebSocketListener listener)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Uses {@code request} to connect a new web socket.
  jni.JObject newWebSocket(
    request_.Request request,
    jni.JObject listener,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_newWebSocket,
        jni.JniCallType.objectType,
        [request.reference, listener.reference]).object);
  }

  static final _id_newBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"newBuilder", r"()Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder newBuilder() {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_newBuilder, jni.JniCallType.objectType, []).object);
  }
}

final class $OkHttpClientType extends jni.JObjType<OkHttpClient> {
  const $OkHttpClientType();

  @override
  String get signature => r"Lokhttp3/OkHttpClient;";

  @override
  OkHttpClient fromRef(jni.JObjectPtr ref) => OkHttpClient.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClientType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClientType) &&
        other is $OkHttpClientType;
  }
}

/// from: okhttp3.OkHttpClient$Builder
class OkHttpClient_Builder extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient_Builder> $type = type;

  OkHttpClient_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"okhttp3/OkHttpClient$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClient_BuilderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient_Builder() {
    return OkHttpClient_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);
  }

  static final _id_callTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"callTimeout",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder callTimeout(long timeout, java.util.concurrent.TimeUnit unit)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
  /// must be between 1 and Integer\#MAX_VALUE when converted to milliseconds.
  ///
  /// The call timeout spans the entire call: resolving DNS, connecting, writing the request
  /// body, server processing, and reading the response body. If the call requires redirects or
  /// retries all must complete within one timeout period.
  ///
  /// The default value is 0 which imposes no timeout.
  OkHttpClient_Builder callTimeout(
    int timeout,
    jni.JObject unit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_callTimeout,
            jni.JniCallType.objectType, [timeout, unit.reference]).object);
  }

  static final _id_callTimeout1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"callTimeout",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder callTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
  /// must be between 1 and Integer\#MAX_VALUE when converted to milliseconds.
  ///
  /// The call timeout spans the entire call: resolving DNS, connecting, writing the request
  /// body, server processing, and reading the response body. If the call requires redirects or
  /// retries all must complete within one timeout period.
  ///
  /// The default value is 0 which imposes no timeout.
  OkHttpClient_Builder callTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_callTimeout1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_connectTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"connectTimeout",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder connectTimeout(long timeout, java.util.concurrent.TimeUnit unit)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the default connect timeout for new connections. A value of 0 means no timeout,
  /// otherwise values must be between 1 and Integer\#MAX_VALUE when converted to
  /// milliseconds.
  ///
  /// The connect timeout is applied when connecting a TCP socket to the target host.
  /// The default value is 10 seconds.
  OkHttpClient_Builder connectTimeout(
    int timeout,
    jni.JObject unit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectTimeout,
            jni.JniCallType.objectType, [timeout, unit.reference]).object);
  }

  static final _id_connectTimeout1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"connectTimeout",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder connectTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the default connect timeout for new connections. A value of 0 means no timeout,
  /// otherwise values must be between 1 and Integer\#MAX_VALUE when converted to
  /// milliseconds.
  ///
  /// The connect timeout is applied when connecting a TCP socket to the target host.
  /// The default value is 10 seconds.
  OkHttpClient_Builder connectTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectTimeout1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_readTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readTimeout",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder readTimeout(long timeout, java.util.concurrent.TimeUnit unit)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
  /// values must be between 1 and Integer\#MAX_VALUE when converted to milliseconds.
  ///
  /// The read timeout is applied to both the TCP socket and for individual read IO operations
  /// including on Source of the Response. The default value is 10 seconds.
  ///@see Socket\#setSoTimeout(int)
  ///@see Source\#timeout()
  OkHttpClient_Builder readTimeout(
    int timeout,
    jni.JObject unit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readTimeout,
            jni.JniCallType.objectType, [timeout, unit.reference]).object);
  }

  static final _id_readTimeout1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"readTimeout",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder readTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
  /// values must be between 1 and Integer\#MAX_VALUE when converted to milliseconds.
  ///
  /// The read timeout is applied to both the TCP socket and for individual read IO operations
  /// including on Source of the Response. The default value is 10 seconds.
  ///@see Socket\#setSoTimeout(int)
  ///@see Source\#timeout()
  OkHttpClient_Builder readTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_readTimeout1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_writeTimeout = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeTimeout",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder writeTimeout(long timeout, java.util.concurrent.TimeUnit unit)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
  /// values must be between 1 and Integer\#MAX_VALUE when converted to milliseconds.
  ///
  /// The write timeout is applied for individual write IO operations.
  /// The default value is 10 seconds.
  ///@see Sink\#timeout()
  OkHttpClient_Builder writeTimeout(
    int timeout,
    jni.JObject unit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeTimeout,
            jni.JniCallType.objectType, [timeout, unit.reference]).object);
  }

  static final _id_writeTimeout1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"writeTimeout",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder writeTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
  /// values must be between 1 and Integer\#MAX_VALUE when converted to milliseconds.
  ///
  /// The write timeout is applied for individual write IO operations.
  /// The default value is 10 seconds.
  ///@see Sink\#timeout()
  OkHttpClient_Builder writeTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_writeTimeout1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_pingInterval = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"pingInterval",
      r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder pingInterval(long interval, java.util.concurrent.TimeUnit unit)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
  /// automatically send ping frames until either the connection fails or it is closed. This keeps
  /// the connection alive and may detect connectivity failures.
  ///
  /// If the server does not respond to each ping with a pong within {@code interval}, this
  /// client will assume that connectivity has been lost. When this happens on a web socket the
  /// connection is canceled and its listener is {@linkplain WebSocketListener\#onFailure notified
  /// of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
  /// calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
  ///
  /// The default value of 0 disables client-initiated pings.
  OkHttpClient_Builder pingInterval(
    int interval,
    jni.JObject unit,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_pingInterval,
            jni.JniCallType.objectType, [interval, unit.reference]).object);
  }

  static final _id_pingInterval1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"pingInterval",
      r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder pingInterval(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
  /// automatically send ping frames until either the connection fails or it is closed. This keeps
  /// the connection alive and may detect connectivity failures.
  ///
  /// If the server does not respond to each ping with a pong within {@code interval}, this
  /// client will assume that connectivity has been lost. When this happens on a web socket the
  /// connection is canceled and its listener is {@linkplain WebSocketListener\#onFailure notified
  /// of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
  /// calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
  ///
  /// The default value of 0 disables client-initiated pings.
  OkHttpClient_Builder pingInterval1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_pingInterval1,
            jni.JniCallType.objectType, [duration.reference]).object);
  }

  static final _id_proxy = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"proxy", r"(Ljava/net/Proxy;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder proxy(java.net.Proxy proxy)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the HTTP proxy that will be used by connections created by this client. This takes
  /// precedence over \#proxySelector, which is only honored when this proxy is null (which
  /// it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.
  OkHttpClient_Builder proxy(
    jni.JObject proxy,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_proxy, jni.JniCallType.objectType,
            [proxy.reference]).object);
  }

  static final _id_proxySelector = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"proxySelector",
      r"(Ljava/net/ProxySelector;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder proxySelector(java.net.ProxySelector proxySelector)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the proxy selection policy to be used if no \#proxy proxy is specified
  /// explicitly. The proxy selector may return multiple proxies; in that case they will be tried
  /// in sequence until a successful connection is established.
  ///
  /// If unset, the ProxySelector\#getDefault() system-wide default proxy selector will
  /// be used.
  OkHttpClient_Builder proxySelector(
    jni.JObject proxySelector,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_proxySelector,
            jni.JniCallType.objectType, [proxySelector.reference]).object);
  }

  static final _id_cookieJar = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"cookieJar", r"(Lokhttp3/CookieJar;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder cookieJar(okhttp3.CookieJar cookieJar)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
  /// outgoing HTTP requests.
  ///
  /// If unset, {@linkplain CookieJar\#NO_COOKIES no cookies} will be accepted nor provided.
  OkHttpClient_Builder cookieJar(
    jni.JObject cookieJar,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_cookieJar,
            jni.JniCallType.objectType, [cookieJar.reference]).object);
  }

  static final _id_cache = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"cache", r"(Lokhttp3/Cache;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder cache(okhttp3.Cache cache)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the response cache to be used to read and write cached responses.
  OkHttpClient_Builder cache(
    jni.JObject cache,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_cache, jni.JniCallType.objectType,
            [cache.reference]).object);
  }

  static final _id_dns = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"dns", r"(Lokhttp3/Dns;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder dns(okhttp3.Dns dns)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the DNS service used to lookup IP addresses for hostnames.
  ///
  /// If unset, the Dns\#SYSTEM system-wide default DNS will be used.
  OkHttpClient_Builder dns(
    jni.JObject dns,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_dns, jni.JniCallType.objectType,
            [dns.reference]).object);
  }

  static final _id_socketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"socketFactory",
      r"(Ljavax/net/SocketFactory;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder socketFactory(javax.net.SocketFactory socketFactory)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the socket factory used to create connections. OkHttp only uses the parameterless SocketFactory\#createSocket() createSocket() method to create unconnected sockets. Overriding
  /// this method, e. g., allows the socket to be bound to a specific local address.
  ///
  /// If unset, the SocketFactory\#getDefault() system-wide default socket factory will
  /// be used.
  OkHttpClient_Builder socketFactory(
    jni.JObject socketFactory,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_socketFactory,
            jni.JniCallType.objectType, [socketFactory.reference]).object);
  }

  static final _id_sslSocketFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"sslSocketFactory",
      r"(Ljavax/net/ssl/SSLSocketFactory;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder sslSocketFactory(javax.net.ssl.SSLSocketFactory sslSocketFactory)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the socket factory used to secure HTTPS connections. If unset, the system default will
  /// be used.
  ///@deprecated {@code SSLSocketFactory} does not expose its X509TrustManager, which is
  ///     a field that OkHttp needs to build a clean certificate chain. This method instead must
  ///     use reflection to extract the trust manager. Applications should prefer to call \#sslSocketFactory(SSLSocketFactory, X509TrustManager), which avoids such reflection.
  OkHttpClient_Builder sslSocketFactory(
    jni.JObject sslSocketFactory,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_sslSocketFactory,
            jni.JniCallType.objectType, [sslSocketFactory.reference]).object);
  }

  static final _id_sslSocketFactory1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"sslSocketFactory",
      r"(Ljavax/net/ssl/SSLSocketFactory;Ljavax/net/ssl/X509TrustManager;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder sslSocketFactory(javax.net.ssl.SSLSocketFactory sslSocketFactory, javax.net.ssl.X509TrustManager trustManager)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
  /// system defaults will be used.
  ///
  /// Most applications should not call this method, and instead use the system defaults. Those
  /// classes include special optimizations that can be lost if the implementations are decorated.
  ///
  /// If necessary, you can create and configure the defaults yourself with the following code:
  ///
  /// <pre>   {@code
  ///
  ///   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
  ///       TrustManagerFactory.getDefaultAlgorithm());
  ///   trustManagerFactory.init((KeyStore) null);
  ///   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
  ///   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
  ///     throw new IllegalStateException("Unexpected default trust managers:"
  ///         + Arrays.toString(trustManagers));
  ///   }
  ///   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
  ///
  ///   SSLContext sslContext = SSLContext.getInstance("TLS");
  ///   sslContext.init(null, new TrustManager[] { trustManager }, null);
  ///   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
  ///
  ///   OkHttpClient client = new OkHttpClient.Builder()
  ///       .sslSocketFactory(sslSocketFactory, trustManager)
  ///       .build();
  /// }</pre>
  OkHttpClient_Builder sslSocketFactory1(
    jni.JObject sslSocketFactory,
    jni.JObject trustManager,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_sslSocketFactory1,
            jni.JniCallType.objectType,
            [sslSocketFactory.reference, trustManager.reference]).object);
  }

  static final _id_hostnameVerifier = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"hostnameVerifier",
      r"(Ljavax/net/ssl/HostnameVerifier;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder hostnameVerifier(javax.net.ssl.HostnameVerifier hostnameVerifier)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the verifier used to confirm that response certificates apply to requested hostnames for
  /// HTTPS connections.
  ///
  /// If unset, a default hostname verifier will be used.
  OkHttpClient_Builder hostnameVerifier(
    jni.JObject hostnameVerifier,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_hostnameVerifier,
            jni.JniCallType.objectType, [hostnameVerifier.reference]).object);
  }

  static final _id_certificatePinner = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"certificatePinner",
      r"(Lokhttp3/CertificatePinner;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder certificatePinner(okhttp3.CertificatePinner certificatePinner)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
  /// connections rely on only the \#sslSocketFactory SSL socket factory to establish trust.
  /// Pinning certificates avoids the need to trust certificate authorities.
  OkHttpClient_Builder certificatePinner(
    jni.JObject certificatePinner,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_certificatePinner,
            jni.JniCallType.objectType, [certificatePinner.reference]).object);
  }

  static final _id_authenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"authenticator",
      r"(Lokhttp3/Authenticator;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder authenticator(okhttp3.Authenticator authenticator)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the authenticator used to respond to challenges from origin servers. Use \#proxyAuthenticator to set the authenticator for proxy servers.
  ///
  /// If unset, the {@linkplain Authenticator\#NONE no authentication will be attempted}.
  OkHttpClient_Builder authenticator(
    jni.JObject authenticator,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_authenticator,
            jni.JniCallType.objectType, [authenticator.reference]).object);
  }

  static final _id_proxyAuthenticator = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"proxyAuthenticator",
      r"(Lokhttp3/Authenticator;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder proxyAuthenticator(okhttp3.Authenticator proxyAuthenticator)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the authenticator used to respond to challenges from proxy servers. Use \#authenticator to set the authenticator for origin servers.
  ///
  /// If unset, the {@linkplain Authenticator\#NONE no authentication will be attempted}.
  OkHttpClient_Builder proxyAuthenticator(
    jni.JObject proxyAuthenticator,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_proxyAuthenticator,
            jni.JniCallType.objectType, [proxyAuthenticator.reference]).object);
  }

  static final _id_connectionPool = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"connectionPool",
      r"(Lokhttp3/ConnectionPool;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder connectionPool(okhttp3.ConnectionPool connectionPool)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the connection pool used to recycle HTTP and HTTPS connections.
  ///
  /// If unset, a new connection pool will be used.
  OkHttpClient_Builder connectionPool(
    jni.JObject connectionPool,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectionPool,
            jni.JniCallType.objectType, [connectionPool.reference]).object);
  }

  static final _id_followSslRedirects = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"followSslRedirects",
      r"(Z)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder followSslRedirects(boolean followProtocolRedirects)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
  ///
  /// If unset, protocol redirects will be followed. This is different than the built-in {@code
  /// HttpURLConnection}'s default.
  OkHttpClient_Builder followSslRedirects(
    bool followProtocolRedirects,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_followSslRedirects,
            jni.JniCallType.objectType,
            [followProtocolRedirects ? 1 : 0]).object);
  }

  static final _id_followRedirects = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"followRedirects",
      r"(Z)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder followRedirects(boolean followRedirects)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Configure this client to follow redirects. If unset, redirects will be followed.
  OkHttpClient_Builder followRedirects(
    bool followRedirects,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_followRedirects,
            jni.JniCallType.objectType, [followRedirects ? 1 : 0]).object);
  }

  static final _id_retryOnConnectionFailure = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"retryOnConnectionFailure",
      r"(Z)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder retryOnConnectionFailure(boolean retryOnConnectionFailure)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Configure this client to retry or not when a connectivity problem is encountered. By default,
  /// this client silently recovers from the following problems:
  ///
  /// <ul>
  ///   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
  ///       failure to reach any individual IP address doesn't fail the overall request. This can
  ///       increase availability of multi-homed services.
  ///   <li><strong>Stale pooled connections.</strong> The ConnectionPool reuses sockets
  ///       to decrease request latency, but these connections will occasionally time out.
  ///   <li><strong>Unreachable proxy servers.</strong> A ProxySelector can be used to
  ///       attempt multiple proxy servers in sequence, eventually falling back to a direct
  ///       connection.
  /// </ul>
  ///
  /// Set this to false to avoid retrying requests when doing so is destructive. In this case the
  /// calling application should do its own recovery of connectivity failures.
  OkHttpClient_Builder retryOnConnectionFailure(
    bool retryOnConnectionFailure,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_retryOnConnectionFailure,
            jni.JniCallType.objectType,
            [retryOnConnectionFailure ? 1 : 0]).object);
  }

  static final _id_dispatcher = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"dispatcher",
      r"(Lokhttp3/Dispatcher;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder dispatcher(okhttp3.Dispatcher dispatcher)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
  OkHttpClient_Builder dispatcher(
    jni.JObject dispatcher,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_dispatcher,
            jni.JniCallType.objectType, [dispatcher.reference]).object);
  }

  static final _id_protocols = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r"protocols", r"(Ljava/util/List;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder protocols(java.util.List<okhttp3.Protocol> protocols)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Configure the protocols used by this client to communicate with remote servers. By default
  /// this client will prefer the most efficient transport available, falling back to more
  /// ubiquitous protocols. Applications should only call this method to avoid specific
  /// compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
  ///
  /// The following protocols are currently supported:
  ///
  /// <ul>
  ///     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
  ///     <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>
  ///     <li><a href="https://tools.ietf.org/html/rfc7540\#section-3.4">h2 with prior knowledge
  ///         (cleartext only)</a>
  /// </ul>
  ///
  /// <strong>This is an evolving set.</strong> Future releases include support for transitional
  /// protocols. The http/1.1 transport will never be dropped.
  ///
  /// If multiple protocols are specified, <a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
  /// negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.
  ///
  /// Protocol\#HTTP_1_0 is not supported in this set. Requests are initiated with {@code
  /// HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by Response\#protocol().
  ///@param protocols the protocols to use, in order of preference. If the list contains Protocol\#H2_PRIOR_KNOWLEDGE then that must be the only protocol and HTTPS URLs will not
  ///     be supported. Otherwise the list must contain Protocol\#HTTP_1_1. The list must
  ///     not contain null or Protocol\#HTTP_1_0.
  OkHttpClient_Builder protocols(
    jni.JList<jni.JObject> protocols,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_protocols,
            jni.JniCallType.objectType, [protocols.reference]).object);
  }

  static final _id_connectionSpecs = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"connectionSpecs",
      r"(Ljava/util/List;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder connectionSpecs(java.util.List<okhttp3.ConnectionSpec> connectionSpecs)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectionSpecs(
    jni.JList<jni.JObject> connectionSpecs,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_connectionSpecs,
            jni.JniCallType.objectType, [connectionSpecs.reference]).object);
  }

  static final _id_interceptors = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"interceptors", r"()Ljava/util/List;");

  /// from: public java.util.List<okhttp3.Interceptor> interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a modifiable list of interceptors that observe the full span of each call: from
  /// before the connection is established (if any) until after the response source is selected
  /// (either the origin server, cache, or both).
  jni.JList<jni.JObject> interceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_interceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_addInterceptor = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addInterceptor",
      r"(Lokhttp3/Interceptor;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder addInterceptor(okhttp3.Interceptor interceptor)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addInterceptor(
    jni.JObject interceptor,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addInterceptor,
            jni.JniCallType.objectType, [interceptor.reference]).object);
  }

  static final _id_networkInterceptors = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"networkInterceptors", r"()Ljava/util/List;");

  /// from: public java.util.List<okhttp3.Interceptor> networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a modifiable list of interceptors that observe a single network request and response.
  /// These interceptors must call Interceptor.Chain\#proceed exactly once: it is an error
  /// for a network interceptor to short-circuit or repeat a network request.
  jni.JList<jni.JObject> networkInterceptors() {
    return const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_networkInterceptors,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_addNetworkInterceptor = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"addNetworkInterceptor",
      r"(Lokhttp3/Interceptor;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder addNetworkInterceptor(okhttp3.Interceptor interceptor)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addNetworkInterceptor(
    jni.JObject interceptor,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addNetworkInterceptor,
            jni.JniCallType.objectType, [interceptor.reference]).object);
  }

  static final _id_eventListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"eventListener",
      r"(Lokhttp3/EventListener;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder eventListener(okhttp3.EventListener eventListener)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Configure a single client scoped listener that will receive all analytic events
  /// for this client.
  ///@see EventListener for semantics and restrictions on listener implementations.
  OkHttpClient_Builder eventListener(
    jni.JObject eventListener,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_eventListener,
            jni.JniCallType.objectType, [eventListener.reference]).object);
  }

  static final _id_eventListenerFactory = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"eventListenerFactory",
      r"(Lokhttp3/EventListener$Factory;)Lokhttp3/OkHttpClient$Builder;");

  /// from: public okhttp3.OkHttpClient.Builder eventListenerFactory(okhttp3.EventListener.Factory eventListenerFactory)
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Configure a factory to provide per-call scoped listeners that will receive analytic events
  /// for this client.
  ///@see EventListener for semantics and restrictions on listener implementations.
  OkHttpClient_Builder eventListenerFactory(
    jni.JObject eventListenerFactory,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_eventListenerFactory,
            jni.JniCallType.objectType,
            [eventListenerFactory.reference]).object);
  }

  static final _id_build = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"build", r"()Lokhttp3/OkHttpClient;");

  /// from: public okhttp3.OkHttpClient build()
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient build() {
    return const $OkHttpClientType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_build, jni.JniCallType.objectType, []).object);
  }
}

final class $OkHttpClient_BuilderType
    extends jni.JObjType<OkHttpClient_Builder> {
  const $OkHttpClient_BuilderType();

  @override
  String get signature => r"Lokhttp3/OkHttpClient$Builder;";

  @override
  OkHttpClient_Builder fromRef(jni.JObjectPtr ref) =>
      OkHttpClient_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClient_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClient_BuilderType) &&
        other is $OkHttpClient_BuilderType;
  }
}
